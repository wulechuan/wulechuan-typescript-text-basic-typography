'use strict'
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i]
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p]
        }
        return t
    }
    return __assign.apply(this, arguments)
}
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i)
            ar[i] = from[i]
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from))
}
Object.defineProperty(exports, '__esModule', { value: true })
exports.对文本列表逐项分割并将结果列表展平 = exports.将原文本改造为包含简朴排版的新文本 = void 0
function 将原文本改造为包含简朴排版的新文本(_a) {
    var _b = _a === void 0 ? {} : _a, 原文本 = _b.原文本, 列表引领符 = _b.列表引领符, 单层缩进空格数或单层缩进之文本 = _b.单层缩进空格数或单层缩进之文本, 整体缩进级数 = _b.整体缩进级数, 各段落间的额外空白行数 = _b.各段落间的额外空白行数
    var 单层缩进之文本 = ' '.repeat(4)
    if (typeof 单层缩进空格数或单层缩进之文本 === 'string') {
        if (单层缩进空格数或单层缩进之文本.trim()) {
            单层缩进之文本 = 单层缩进空格数或单层缩进之文本
        }
        else {
            var 等效的数字 = +单层缩进空格数或单层缩进之文本
            if (0 < 等效的数字 && 等效的数字 < 128) {
                单层缩进之文本 = ' '.repeat(等效的数字)
            }
            else {
                单层缩进之文本 = 单层缩进空格数或单层缩进之文本
            }
        }
    }
    else if (typeof 单层缩进空格数或单层缩进之文本 === 'number') {
        if (0 < 单层缩进空格数或单层缩进之文本 && 单层缩进空格数或单层缩进之文本 < 128) {
            单层缩进之文本 = ' '.repeat(单层缩进空格数或单层缩进之文本)
        }
    }
    if (typeof 列表引领符 !== 'string') {
        列表引领符 = '- '
    }
    整体缩进级数 = +(整体缩进级数 || 0)
    if (!(整体缩进级数 > 0)) {
        整体缩进级数 = 0
    }
    各段落间的额外空白行数 = +(各段落间的额外空白行数 || -1)
    if (!(各段落间的额外空白行数 >= 0)) {
        各段落间的额外空白行数 = 1
    }
    var 整体缩进之文本 = 单层缩进之文本.repeat(整体缩进级数)
    var 首层缩进之文本 = ''
    var 首层缩进之文本_含列表引领符 = ''
    if (列表引领符.length > 0) {
        首层缩进之文本 = 单层缩进之文本.repeat(Math.ceil((列表引领符.length + 1) / 单层缩进之文本.length))
        首层缩进之文本_含列表引领符 = ''.concat(首层缩进之文本.slice(0, -列表引领符.length)).concat(列表引领符)
    }
    var 非首层之单层缩进之文本 = 单层缩进之文本
    var 首层缩进之文本_并含整体缩进 = ''.concat(整体缩进之文本).concat(首层缩进之文本)
    var 首层缩进之文本_含列表引领符_并含整体缩进 = ''.concat(整体缩进之文本).concat(首层缩进之文本_含列表引领符)
    var 各段落文本之列表 = [原文本];
    [
        { 分割符或分割正则表达式: /。 {2,}/, 在分割符处须补回的内容: '。' },
        { 分割符或分割正则表达式: /！ {2,}/, 在分割符处须补回的内容: '！' },
        { 分割符或分割正则表达式: /？ {2,}/, 在分割符处须补回的内容: '？' },
        { 分割符或分割正则表达式: /” {3,}/, 在分割符处须补回的内容: '”' },
        { 分割符或分割正则表达式: /： {2,}/, 在分割符处须补回的内容: '：' },
        { 分割符或分割正则表达式: /…… {2,}/, 在分割符处须补回的内容: '……' },
        { 分割符或分割正则表达式: /\n{2,}|\n +/, 在分割符处须补回的内容: '' },
        { 分割符或分割正则表达式: /\r{2,}|\r +/, 在分割符处须补回的内容: '' },
        { 分割符或分割正则表达式: /(\r\n){2,}|\r\n +/, 在分割符处须补回的内容: '' },
    ].forEach(function (分割方案) {
        各段落文本之列表 = (0, exports.对文本列表逐项分割并将结果列表展平)(__assign({ 原文本或原文本列表: 各段落文本之列表 }, 分割方案))
    })
    var 各段落文本列表之列表 = 各段落文本之列表.map(function (某段落之文本) {
        var 某段落中各行文本之列表 = [某段落之文本];
        [
            { 分割符或分割正则表达式: /。 /, 在分割符处须补回的内容: '。' },
            { 分割符或分割正则表达式: /！ /, 在分割符处须补回的内容: '！' },
            { 分割符或分割正则表达式: /？ /, 在分割符处须补回的内容: '？' },
            { 分割符或分割正则表达式: /” {2}/, 在分割符处须补回的内容: '”' },
            { 分割符或分割正则表达式: /： /, 在分割符处须补回的内容: '：' },
            { 分割符或分割正则表达式: /…… /, 在分割符处须补回的内容: '……' },
            { 分割符或分割正则表达式: /、 +/, 在分割符处须补回的内容: '、' },
            { 分割符或分割正则表达式: /， +/, 在分割符处须补回的内容: '，' },
            { 分割符或分割正则表达式: /； +/, 在分割符处须补回的内容: '；' },
            { 分割符或分割正则表达式: /\n/, 在分割符处须补回的内容: '' },
            { 分割符或分割正则表达式: /\r/, 在分割符处须补回的内容: '' },
            { 分割符或分割正则表达式: /\r\n/, 在分割符处须补回的内容: '' },
        ].forEach(function (分割方案) {
            某段落中各行文本之列表 = (0, exports.对文本列表逐项分割并将结果列表展平)(__assign({ 原文本或原文本列表: 某段落中各行文本之列表 }, 分割方案))
        })
        return 某段落中各行文本之列表
    })
    var 排版好的内容全文 = 各段落文本列表之列表.map(function (某段落中各行文本之列表) {
        return 某段落中各行文本之列表.map(function (某行之文本, 行之内部编号) {
            var 行号 = 行之内部编号 + 1
            var 行前缀内容 = ''.concat(整体缩进之文本).concat(行号 === 1 ? 首层缩进之文本_含列表引领符 : 首层缩进之文本)
            return ''.concat(行前缀内容).concat(某行之文本)
        }).join('\n')
    }).join('\n'.repeat(1 + 各段落间的额外空白行数))
    var 产出 = {
        排版好的内容全文: 排版好的内容全文,
        分割好的内容结构树: 各段落文本列表之列表,
        最终采纳的排版配置: {
            整体缩进级数: 整体缩进级数,
            整体缩进之文本: 整体缩进之文本,
            列表引领符: 列表引领符,
            首层缩进之文本: 首层缩进之文本,
            首层缩进之文本_并含整体缩进: 首层缩进之文本_并含整体缩进,
            首层缩进之文本_含列表引领符: 首层缩进之文本_含列表引领符,
            首层缩进之文本_含列表引领符_并含整体缩进: 首层缩进之文本_含列表引领符_并含整体缩进,
            非首层之单层缩进之文本: 非首层之单层缩进之文本,
            各段落间的额外空白行数: 各段落间的额外空白行数,
        },
    }
    return 产出
}
exports.将原文本改造为包含简朴排版的新文本 = 将原文本改造为包含简朴排版的新文本
var 对文本列表逐项分割并将结果列表展平 = function (配置项集) {
    if (!配置项集 || typeof 配置项集 !== 'object') {
        配置项集 = {}
    }
    var 原文本或原文本列表_给出值 = 配置项集.原文本或原文本列表, 分割符或分割正则表达式_给出值 = 配置项集.分割符或分割正则表达式, 在分割符处须补回的内容_给出值 = 配置项集.在分割符处须补回的内容
    var 原文本列表_采纳值1
    if (typeof 原文本或原文本列表_给出值 === 'string') {
        原文本列表_采纳值1 = [原文本或原文本列表_给出值]
    }
    else if (Array.isArray(原文本或原文本列表_给出值)) {
        原文本列表_采纳值1 = 原文本或原文本列表_给出值
    }
    else {
        原文本列表_采纳值1 = []
    }
    var 原文本列表_采纳值2 = 原文本列表_采纳值1.filter(function (某项内容) { return typeof 某项内容 === 'string' && !!某项内容 })
    if (原文本列表_采纳值2.length < 1) {
        return 原文本或原文本列表_给出值
    }
    var 在分割符处须补回内容未给出 = typeof 在分割符处须补回的内容_给出值 !== 'string'
    var 分割符或分割正则表达式_采纳值
    var 分割符等效的文本 = ''
    var 在分割符处须补回的内容_采纳值
    var 分割符为正则表达式时补回内容却未给出 = false
    if (typeof 分割符或分割正则表达式_给出值 === 'string') {
        分割符或分割正则表达式_采纳值 = 分割符或分割正则表达式_给出值
        分割符等效的文本 = 分割符或分割正则表达式_给出值
    }
    else {
        if (分割符或分割正则表达式_给出值 instanceof RegExp) {
            分割符或分割正则表达式_采纳值 = 分割符或分割正则表达式_给出值
            分割符等效的文本 = 分割符或分割正则表达式_给出值.toString()
            分割符为正则表达式时补回内容却未给出 = 在分割符处须补回内容未给出
        }
        else {
            分割符或分割正则表达式_采纳值 = ''
        }
    }
    if (!在分割符处须补回内容未给出) {
        在分割符处须补回的内容_采纳值 = 在分割符处须补回的内容_给出值
    }
    else {
        在分割符处须补回的内容_采纳值 = 分割符等效的文本
        if (分割符为正则表达式时补回内容却未给出) {
            console.warn('\u7ED9\u51FA\u7684\u3010\u5206\u5272\u7B26\u3011\u7CFB\u6B63\u5219\u8868\u8FBE\u5F0F\uFF0C\u4F46\u3010\u5206\u5272\u7B26\u5904\u987B\u8865\u56DE\u7684\u5185\u5BB9\u3011\u5E76\u672A\u660E\u786E\u7ED9\u51FA\u3002\u6545\u8865\u56DE\u7684\u5185\u5BB9\u662F\u4E0D\u53EF\u9760\u7684\uFF01\u636E\u76EE\u524D\u7ED9\u51FA\u7684\u914D\u7F6E\uFF0C\u62DF\u5728\u5404\u5206\u5272\u5904\u8865\u56DE\u8BE5\u5185\u5BB9\uFF1A "'.concat(在分割符处须补回的内容_采纳值, '"\u3002'))
        }
    }
    if (!分割符或分割正则表达式_采纳值) {
        console.debug('【分割符】为空字符串。')
    }
    var 两级嵌套之列表 = 原文本列表_采纳值2.map(function (原文某项文本) {
        return 原文某项文本.split(分割符或分割正则表达式_采纳值).map(function (分割后的某文本片段, 片段之内部编号, 分割得到的片段列表) {
            var 不是最末的片段 = 片段之内部编号 < 分割得到的片段列表.length - 1
            return 不是最末的片段 ? ''.concat(分割后的某文本片段).concat(在分割符处须补回的内容_采纳值) : 分割后的某文本片段
        })
    })
    var 展平后的单级列表 = 两级嵌套之列表.reduce(function (展平后的文本片段列表, 某原文本分割而得的片段列表) {
        return __spreadArray(__spreadArray([], 展平后的文本片段列表, true), 某原文本分割而得的片段列表, true)
    }, [])
    return 展平后的单级列表
}
exports.对文本列表逐项分割并将结果列表展平 = 对文本列表逐项分割并将结果列表展平
