/* eslint-disable @typescript-eslint/no-unused-vars */

import path from 'node:path'
import fs from 'node:fs'


import {
    将原文本改造为包含简朴排版的新文本,
    对文本列表逐项分割并将结果列表展平,
} from '../源代码/发布的源代码/index.js'









;[
    测试任务甲,
    测试任务乙,
    测试任务丙,
    测试任务丁,
    测试任务戊,
    测试任务己,
].forEach((测试任务, 任务内部编号, 任务列表) => {
    if (typeof 测试任务 !== 'function') { return }
    console.log(`\n\n${'='.repeat(19)} 【 测试进程号（pid）`, process.pid, '】测试任务', 任务内部编号 + 1, `${'='.repeat(45)}\n\n`)
    测试任务()
    任务内部编号 === 任务列表.length - 1 && console.log(`\n\n ${'~ * '.repeat(26)}\n\n`)
})









function 测试任务甲 () {
    /** @type {import('../package.json')} */
    const 本工具集自身之_packageJSON =  JSON.parse(fs.readFileSync(path.resolve('package.json')))
    console.log(`《${本工具集自身之_packageJSON.name} 简介》\n`)
    console.log(将原文本改造为包含简朴排版的新文本({
        原文本: 本工具集自身之_packageJSON.description,
        列表引领符: '· ',
        单层缩进空格数或单层缩进之文本: 8,
    }).排版好的内容全文)
}









function 测试任务乙 () {
    console.log(将原文本改造为包含简朴排版的新文本({
        原文本: '时间要打多久，我讲我们不要做决定。 过去是由杜鲁门，以后是由艾森豪威尔， 或者是美国的将来的什么总统，由他们去决定。 就是说他们要打多久就打多久！ 一直打到完全胜利！',
        列表引领符: '',
    }).排版好的内容全文)
}









function 测试任务丙 () {
    console.log(将原文本改造为包含简朴排版的新文本({
        原文本: '《九色鹿》是根据敦煌壁画《鹿王本生》故事改编， 由中国上海美术电影制片厂 1981 年出品的动画美术作品。 由钱家骏、戴铁郎担任导演，潘絜兹任编剧。  该片采用敦煌壁画的形式，用中国古代佛教绘画的风格讲述了九色鹿经常帮助遇到困难的人， 在帮助过弄蛇人后，弄蛇人向国王告密出卖九色鹿， 九色鹿用神力化险，弄蛇人受到应有报应的故事。',
        列表引领符: '',
    }).排版好的内容全文)
}









function 测试任务丁 () {
    const 正文原文 = '中国人——特别是汉族人，理应坚持广泛、规范地使用汉语。  凡非必要之情形不说外国话、不用外国字。  此乃天经地义！  然则每当必要， 亦不排斥采用外国之语言。  不妨博世界之学问，养中国之精神。'

    const 释文原文 = '首先，上例中的 “列表引领符” 故意设计得很长， 其长度远超过“单级缩进”。 此时，本工具会自动令首层缩进加深， 以确保首层缩进足够宽，可容纳列表引领符， 进而确保列表中的文字左侧齐平。\n\n其次，有些地方的逗号后面是换行的，另有一些逗号后面则不换行。  再有，默认配置下，每个段落之间留有一个空白行。 并且空白行之数量是可配置的。特别的，可以配为零。\n 另外，你有没有考虑过汉语的问号呢？  瞧，问号后面也可以另起一段的。  在计算机的世界中，汉语的省略号是两个字符组合而成的。 因此，单个的“… ”符号，即便其后面故意留有一个空格， 也不会另起一行或另起一段。 非要两个连续的符号组成完整的省略号方可行得通。 例如这样：艺术家们的伟大作品有《马踏飞燕》、 《韩熙载夜宴图》、《千里江山图》、《清明上河图》、 《八骏图》……  还有许许多多的花鸟画、山水画等等，不一而足。'

    const {
        排版好的内容全文: 排版好的内容全文_正文,
        分割好的内容结构树: 分割好的内容结构树_正文,
        最终采纳的排版配置: 正文最终采纳的排版配置,
    } = 将原文本改造为包含简朴排版的新文本({
        原文本: 正文原文,
        列表引领符: '(| ~O \\O) :  ->  ',
    })

    const {
        排版好的内容全文: 排版好的内容全文_注释,
        分割好的内容结构树: 分割好的内容结构树_注释,
    } = 将原文本改造为包含简朴排版的新文本({
        原文本: 释文原文,

        ...正文最终采纳的排版配置,

        列表引领符: '* ',
    })

    console.log(`${
        '下面有几句话要说：'
    }\n\n${
        排版好的内容全文_正文
    }\n\n- 完 -\n\n\n\n${
        '可以看到，上方的排版结果揭示了本工具的不少特性。例如：'
    }\n\n${
        排版好的内容全文_注释
    }\n\n\n`)

    console.log('\n其实，原始的“正文”如下，其中没有一处换行符。')
    console.log(`${'-'.repeat(79)}\n${正文原文}\n${'-'.repeat(79)}\n\n`)
    console.log('\n其实，原始的“释文”如下，可以看到在“其次”、“另外”两词前面故意留有换行符。')
    console.log(`${'-'.repeat(79)}\n${释文原文}\n${'-'.repeat(79)}\n\n`)

    console.log('\n\n\n')
    console.log(分割好的内容结构树_正文)
    console.log(`\n${'-'.repeat(79)}\n`)
    console.log(分割好的内容结构树_注释)
    console.log('\n\n\n')
}








function 测试任务戊 () {
    const 原文本 = '2014 年 3 月，欧特克公司发布 SOFTIMAGE 全线产品的停产声明。 Softimage|xsi 2015 版将成为该软件最后的发行版本。 其中诸多优秀功能（特别是 ICE）将被逐一移植到 Maya 中。  自此，争斗多年的 Maya 和 SOFTIMAGE|XSI（后更名为 Softimage|xsi）， 以前者“吞噬”后者而告终。'

    console.log(将原文本改造为包含简朴排版的新文本({
        原文本,
        列表引领符: '',
    }).排版好的内容全文)
}








function 测试任务己 () {
    // 这里故意试一试调用工具甲时，英语标点符号可否在其后顺利分割。
    // 需指出，本工具集中的工具乙是不处理任何英语标点符号的。

    let 文本列表 = 对文本列表逐项分割并将结果列表展平({
        原文本或原文本列表: 'By understanding how JavaScript works, TypeScript can build a type-system that accepts JavaScript code but has types. This offers a type-system without needing to add extra characters to make types explicit in your code.',

        /** 注意，该【半角句号】之后确有一个空格。 */
        分割符或分割正则表达式: '. ',

        /** 注意，该【半角句号】之后并没有空格。 */
        在分割符处须补回的内容: '.',
    })

    文本列表 = 对文本列表逐项分割并将结果列表展平({
        原文本或原文本列表: 文本列表,

        /** 注意，该【半角逗号】之后确有一个空格。 */
        分割符或分割正则表达式: ', ',

        /** 注意，该【半角逗号】之后并没有空格。 */
        在分割符处须补回的内容: ',',
    })

    文本列表 = 对文本列表逐项分割并将结果列表展平({
        原文本或原文本列表: 文本列表,

        /**
         * 凡词尾为小写字母 s 者，其后分割。
         * 注意，该 s 之后确有一个空格。
         */
        分割符或分割正则表达式: 's ',

        /**
         * 注意，该 s 之后并没有空格。
         */
        在分割符处须补回的内容: 's',
    })

    console.log(文本列表)
}
